---
layout:     post
title:      数学不好的Scipy入门(二)
subtitle:   瞬间ko矩阵乘法的高级操作姿势在这里
date:       2018-3-23
author:     Max
header-img: img/post-bg-rixi2.jpg
catalog: true
tags:
    - Python
    - 爬虫
    - Numpy
    - 科学计算
---


## 前言
看来这个教程是天坑我填不完了【哭哭】填不完了我还要填哼
上次的入门一只讲了一些基础的生成方式，这次我要来学一学操作方式

【放心，我也没学过】

## 正文
对于列表，我们主要的操作方法有以下几种：
- 加减乘除矩阵和转置
- 排序和最值（值和索引）
- 栈和压入和弹出
- 列表的合并的分割
- 转码-decode和encode

- **高级用法-广播**

### 0x01 加减乘除矩阵和转置
由于Numpy是专门用来数学计算的库，所以数学计算什么的也不能少吧
基本的加减乘除都是和原来的计算是一样的，对象* 对象就可以了
值得一提的是，这里的array* array是每一个列表中的元素互相运算，不是所谓的‘矩阵乘法’
```
import numpy as np
>>> a = np.arange(9).reshape((3,3))
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> c = a
>>> c
array([[0, 1, 2],
       [3, 4, 5],
       [6, 7, 8]])
>>> d = c*a
>>> print(d)
[[ 0  1  4]
 [ 9 16 25]
 [36 49 64]]
```
注意到这里是每一项和对应的元素运算，比如第0行第2列的2就是乘以他本身2所以d的（0,2）才会等于四

不同于以往的运算，如果a和c的shape不相同，那么array就是将每一个元素进行操作，这样的思想叫做广播，我后后后后面会讲到

广播思想的简单体现：所有的元素都被* 2了
```
import numpy as np
>>> a = np.arange(9).reshape((3,3))
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> b = a*2
>>> print(b)
[[ 0  2  4]
 [ 6  8 10]
 [12 14 16]]
```

有些时候没事找事干需要用到一些数学函数什么的cos啊sin啊tan90°啊德尔塔（就那个求二元一次的那个）这时候只需呀直接对需要操作的对象进行对应的np方法1就行了【前提你得知道那些函数的英文怎么拼】

举一个例子：cos函数,对于a的每一个值，求他的cos
```
import numpy as np
>>> a = np.arange(9).reshape((3,3))
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> c = *np.cos（a）
>>> c
array([[ 1.        ,  0.54030231, -0.41614684],
       [-0.9899925 , -0.65364362,  0.28366219],
       [ 0.96017029,  0.75390225, -0.14550003]])
```
求平均值的话就需要使用到np.mean或者np.average了，但是average在新里面好像不能使用另外一种array_name.average(name)的形式了，不知道为什么
```
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> print(np.mean(a))
4.0
>>> print(a.mean())
4.0
>>> print(np.average(a))
4.0
>>> print(a.average())
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: 'numpy.ndarray' object has no attribute 'average'
```


## 0x02逻辑判断

有时候我们需要判断array里面大小等于某一个数的元素有多少，这时候就可以在array前面加逻辑语句了，但很神奇这里Numpy又把逻辑语句给广播了，他等于给每一个元素都if了一遍【你要遍历你去反正我不去】

栗子：广播判断array里面有谁是≥5的
```
>>> a = np.arange(9).reshape((3,3))
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> print(a>=5)
[[False False False]
 [False False  True]
 [ True  True  True]]
```
看到上面所有≤5的元素（在1,1之前都是假）

### 0x03 矩阵运算

对于二位数组的运算有一点不一样，百度百科如下：
>[矩阵](https://baike.baidu.com/item/%E7%9F%A9%E9%98%B5/18069)相乘最重要的方法是一般矩阵[乘积](https://baike.baidu.com/item/%E4%B9%98%E7%A7%AF)。它只有在第一个矩阵的列数（column）和第二个矩阵的行数（row）相同时才有意义 。一般单指矩阵乘积时，指的便是一般矩阵乘积。一个m×n的矩阵就是m×n个数排成m行n列的一个数阵。由于它把许多数据紧凑的集中到了一起，所以有时候可以简便地表示一些复杂的模型。

说白了，两矩阵相乘，左矩阵第一行乘以右矩阵第一列（分别相乘，第一个数乘第一个数），乘完之后相加，即为结果的第一行第一列的数，依次往下算......【真鸡儿麻烦都说了我数学是初中水平了】

噗嗤，但是在计算的时候需要注意以下几点：
- 当矩阵A的列数等于矩阵B的行数时，A与B可以相乘。
- 矩阵C的行数等于矩阵A的行数，C的列数等于B的列数。
- 乘积C的第m行第n列的元素等于矩阵A的第m行的元素与矩阵B的第n列对应元素乘积之和。

使用矩阵的运算你可能需要用到这个：
**np.dot（name，name）**
我们来试一下：
```
>>> a = np.arange(9).reshape((3,3))
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> b = a*2
>>> print(b)
[[ 0  2  4]
 [ 6  8 10]
 [12 14 16]]
>>> c_dot = np.dot(a,b)
>>> print(c_dot)
[[ 30  36  42]
 [ 84 108 132]
 [138 180 222]]
```
要不要你手动验算一遍，算对了给你一朵小红花哦
c_dot还有另外一种表达形式
比如说 乘法(a,b)=a*b
那么会不会有a.乘法(b)=a*b呢
虽然我还是更喜欢用第一种，但是还是科普了一下：
```
>>> a = np.arange(9).reshape((3,3))
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> b = a*2
>>> print(b)
[[ 0  2  4]
 [ 6  8 10]
 [12 14 16]]
>>> print(c_dot)
[[ 30  36  42]
 [ 84 108 132]
 [138 180 222]]
>>> print(c_dot2)
[[ 30  36  42]
 [ 84 108 132]
 [138 180 222]]
```
可以看到两个的结果是一样的

这里随便说道一个DFS最短路径什么很好用的东西:
np.random.random( number或者元组）
这个是可以随机产生随机数填充的多维数组的
只是我一直想不明白为什么要写两个random呢.....欢迎dalao在评论区告诉我【貌似自己Blog的评论被墙了至今都还没有修复科科】

这里默认是在0~1之间
```
>>> random_array = np.random.random((3,4))
>>> print(random_array)
[[ 0.67351633  0.10968615  0.20401869  0.34238526]
 [ 0.00286212  0.54137034  0.9844339   0.11619735]
 [ 0.67330579  0.56455508  0.01444559  0.70064595]]
```
接下来我就用这个数组做演示，把几个最值和求和差的函数给讲了

### 0x04 和差计算和最值
#### 1.数值
- np.sum(name,axis = dim) 所有元素的和
- np.min(name,axis = dim)  最小的元素
- np.max(name,axis = dim) 最大的元素

看看一个栗子，
```
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> print(np.sum(a))
36
>>> print(np.max(a))
8
>>> print(np.min(a))
0
```

其中axis=dim的意思是求那个维度上的最值，比如说axis=0就是求每一列里面的最大值
```
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> print(np.max(a,axis=0)) #这个是列
[6 7 8]
>>> print(np.min(a,axis=1)) #这个是行
[0 3 6]
```
对于0列1行的储存方式，有一句口诀什么来着：
>绳子掉进井里面。直的是列，扁的是行！

#### 2.索引
对于索引，只需要将上面的方法名前面加上‘arg’就可以了呢
真？
```
>>> print(a)
[[0 1 2]
 [3 4 5]
 [6 7 8]]
>>> print(np.argmax(a,axis=1))
[2 2 2]
>>> print(np.argmax(a))
8
```
这里讲的索引和以往那些元组不一样（3,4），这里的索引是这个元素在当前维度排在第几位，如np.argmax(a)就等于当前列表中的最后一位，输出出来当然是8，

axis=1就确定了当前的维度是1，所以np.argmax(a,axis=1)就会把每一个维度的max给输出出来，因为每一个维度只有三个元素，所以输出当然是最后一个元素‘2’


## 最后
woc我晚上还要上课先溜了溜了
**这篇文章还没有完结！！！！！**
春季还没有放完，争取一天一更新吧......
感谢阅读吧，毕竟一下子啊东西太多了写不过来
先贴上[莫烦大大的Blog](https://morvanzhou.github.io/)毕竟做的是真的好有兴趣的同志们可以前去观摩
## 最后的最后
[在Max小姐姐的博客上撩人吧](https://0xc000005.github.io/)
